{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"A debug toolbar for FastAPI based on the original django-debug-toolbar . Swagger UI & GraphQL are supported. Installation pip install fastapi-debug-toolbar Info The following packages are automatically installed: Jinja2 for toolbar templates. pyinstrument for profiling support. Quickstart Add DebugToolbarMiddleware middleware to your FastAPI application: from debug_toolbar.middleware import DebugToolbarMiddleware from fastapi import FastAPI app = FastAPI ( debug = True ) app . add_middleware ( DebugToolbarMiddleware ) How it works Once installed, the debug toolbar tab is displayed on the right side of any html page, just click on it to open the navbar. The debug toolbar can be used with Swagger UI or GraphiQL and it is automatically updated after any request using a cookie-based system.","title":"Introduction"},{"location":"#installation","text":"pip install fastapi-debug-toolbar Info The following packages are automatically installed: Jinja2 for toolbar templates. pyinstrument for profiling support.","title":"Installation"},{"location":"#quickstart","text":"Add DebugToolbarMiddleware middleware to your FastAPI application: from debug_toolbar.middleware import DebugToolbarMiddleware from fastapi import FastAPI app = FastAPI ( debug = True ) app . add_middleware ( DebugToolbarMiddleware )","title":"Quickstart"},{"location":"#how-it-works","text":"Once installed, the debug toolbar tab is displayed on the right side of any html page, just click on it to open the navbar. The debug toolbar can be used with Swagger UI or GraphiQL and it is automatically updated after any request using a cookie-based system.","title":"How it works"},{"location":"changelog/","text":"Changelog 0.3.2 Fixed response body stream 0.3.1 Fixed pyproject.toml, added package data Improved panel templates Fixed profiling on Safari browser 0.3.0 Added refresh cookie system and JSON.parse swap removed Fixed SQL query encoding Fixed SQLAlchemyPanel , added missing fastapi_astack to scope ( fastapi >= 0.74.0 ) Added SQLAlchemyPanel.add_engines method Added tortoise-orm >= 0.19.0 support Fixed VersionsPanel JS, package home can be null 0.2.1 Added PydanticPanel Removed current_thread in favor of get_ident Added anyio task groups Removed get_running_loop in favor of get_event_loop Improved tables styles 0.2.0 Fixed ThreadPoolExecutor for all sync endpoints Added cookie-based refresh Added exception handling for dependency resolution Added minor improvements to VersionPanel 0.1.3 Added TortoisePanel 0.1.2 Removed SQL compiled query in favor of statement params Added SQLAlchemy unregister Added SQLPanel base class 0.1.1 Improved dependency resolution Added minor improvements 0.1.0 Added SQLAlchemyPanel Added LOGGING_COLORS to panel templates Minor improvements 0.0.6 Improved VersionsPanel script Added docs 0.0.5 Fixed multiple profilers on the same thread Fixed VersionsPanel Pypi url 0.0.4 Added pypi details to VersionsPanel Improved assets Added LOGGING_COLORS Highlighted matched endpoint 0.0.3 Sorted routes by path 0.0.2 Added mounted apps support (e.g. ariadne.asgi.GraphQL) 0.0.1 \ud83d\udce6","title":"Changelog"},{"location":"changelog/#changelog","text":"","title":"Changelog"},{"location":"changelog/#032","text":"Fixed response body stream","title":"0.3.2"},{"location":"changelog/#031","text":"Fixed pyproject.toml, added package data Improved panel templates Fixed profiling on Safari browser","title":"0.3.1"},{"location":"changelog/#030","text":"Added refresh cookie system and JSON.parse swap removed Fixed SQL query encoding Fixed SQLAlchemyPanel , added missing fastapi_astack to scope ( fastapi >= 0.74.0 ) Added SQLAlchemyPanel.add_engines method Added tortoise-orm >= 0.19.0 support Fixed VersionsPanel JS, package home can be null","title":"0.3.0"},{"location":"changelog/#021","text":"Added PydanticPanel Removed current_thread in favor of get_ident Added anyio task groups Removed get_running_loop in favor of get_event_loop Improved tables styles","title":"0.2.1"},{"location":"changelog/#020","text":"Fixed ThreadPoolExecutor for all sync endpoints Added cookie-based refresh Added exception handling for dependency resolution Added minor improvements to VersionPanel","title":"0.2.0"},{"location":"changelog/#013","text":"Added TortoisePanel","title":"0.1.3"},{"location":"changelog/#012","text":"Removed SQL compiled query in favor of statement params Added SQLAlchemy unregister Added SQLPanel base class","title":"0.1.2"},{"location":"changelog/#011","text":"Improved dependency resolution Added minor improvements","title":"0.1.1"},{"location":"changelog/#010","text":"Added SQLAlchemyPanel Added LOGGING_COLORS to panel templates Minor improvements","title":"0.1.0"},{"location":"changelog/#006","text":"Improved VersionsPanel script Added docs","title":"0.0.6"},{"location":"changelog/#005","text":"Fixed multiple profilers on the same thread Fixed VersionsPanel Pypi url","title":"0.0.5"},{"location":"changelog/#004","text":"Added pypi details to VersionsPanel Improved assets Added LOGGING_COLORS Highlighted matched endpoint","title":"0.0.4"},{"location":"changelog/#003","text":"Sorted routes by path","title":"0.0.3"},{"location":"changelog/#002","text":"Added mounted apps support (e.g. ariadne.asgi.GraphQL)","title":"0.0.2"},{"location":"changelog/#001","text":"\ud83d\udce6","title":"0.0.1"},{"location":"settings/","text":"Here's a list of settings available: Source code in debug_toolbar/settings.py 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 class DebugToolbarSettings ( BaseSettings ): DEFAULT_PANELS : t . List [ str ] = Field ( [ \"debug_toolbar.panels.versions.VersionsPanel\" , \"debug_toolbar.panels.timer.TimerPanel\" , \"debug_toolbar.panels.settings.SettingsPanel\" , \"debug_toolbar.panels.request.RequestPanel\" , \"debug_toolbar.panels.headers.HeadersPanel\" , \"debug_toolbar.panels.pydantic.PydanticPanel\" , \"debug_toolbar.panels.routes.RoutesPanel\" , \"debug_toolbar.panels.logging.LoggingPanel\" , \"debug_toolbar.panels.profiling.ProfilingPanel\" , \"debug_toolbar.panels.redirects.RedirectsPanel\" , ], description = ( \"Specifies the full Python path to each panel that you \" \"want included in the toolbar.\" ), ) PANELS : t . List [ str ] = Field ( [], description = ( \"A list of the full Python paths to each panel that you \" \"want to append to `DEFAULT_PANELS`.\" ), ) DISABLE_PANELS : t . Sequence [ str ] = Field ( [ \"debug_toolbar.panels.redirects.RedirectsPanel\" ], description = ( \"A list of the full Python paths to each panel that you \" \"want disabled (but still displayed) by default.\" ), ) ALLOWED_IPS : t . Optional [ t . Sequence [ IPvAnyAddress ]] = Field ( None , description = ( \"If it's set, the Debug Toolbar is shown only \" \"if your IP address is listed.\" ), ) JINJA_ENV : Environment = Field ( Environment (), description = \"The Jinja environment instance used to render the toolbar.\" , ) JINJA_LOADERS : t . List [ BaseLoader ] = Field ( [], description = ( \"Jinja `BaseLoader` subclasses used to load templates \" \"from the file system or other locations.\" ), ) JINJA_EXTENSIONS : t . Sequence [ t . Union [ str , t . Type [ Extension ]]] = Field ( [], description = ( \"Load the extensions from the list and bind them to the Jinja environment.\" ), ) API_URL : str = Field ( \"/_debug_toolbar\" , description = \"URL prefix to use for toolbar endpoints.\" , ) STATIC_URL : str = Field ( f \" { API_URL . default } /static\" , # type: ignore[attr-defined] description = \"URL to use when referring to toolbar static files.\" , ) SHOW_TOOLBAR_CALLBACK : str = Field ( \"debug_toolbar.middleware.show_toolbar\" , description = ( \"This is the dotted path to a function used for \" \"determining whether the toolbar should show or not.\" ), ) INSERT_BEFORE : str = Field ( \"</body>\" , description = ( \"The toolbar searches for this string in the HTML \" \"and inserts itself just before.\" ), ) SHOW_COLLAPSE : bool = Field ( False , description = \"If changed to `True`, the toolbar will be collapsed by default.\" , ) ROOT_TAG_EXTRA_ATTRS : str = Field ( \"\" , description = ( \"This setting is injected in the root template div \" \"in order to avoid conflicts with client-side frameworks\" ), ) RESULTS_CACHE_SIZE : int = Field ( 25 , description = \"The toolbar keeps up to this many results in memory.\" , ) PROFILER_OPTIONS : t . Dict [ str , t . Any ] = Field ( { \"interval\" : 0.0001 }, description = \"A list of arguments can be supplied to the Profiler.\" , ) SETTINGS : t . Sequence [ BaseSettings ] = Field ( [], description = ( \"pydantic's `BaseSettings` instances to be \" \"displayed on the `SettingsPanel`.\" ), ) LOGGING_COLORS : t . Dict [ str , Color ] = Field ( { \"CRITICAL\" : Color ( \"rgba(255, 0, 0, .4)\" ), \"ERROR\" : Color ( \"rgba(255, 0, 0, .2)\" ), \"WARNING\" : Color ( \"rgba(255, 165, 0, .2)\" ), \"INFO\" : Color ( \"rgba(135, 206, 235, .2)\" ), \"DEBUG\" : Color ( \"rgba(128, 128, 128, .2)\" ), }, description = \"Color palette used to apply colors based on the log level.\" , ) SQL_WARNING_THRESHOLD : int = Field ( 500 , description = ( \"The SQL panel highlights queries that took more that this amount of \" \"time, in milliseconds, to execute.\" ), ) class Config : title = \"Debug Toolbar\" env_prefix = \"DT_\" case_sensitive = True def __init__ ( self , ** settings : t . Any ) -> None : super () . __init__ ( ** settings ) loaders = self . JINJA_LOADERS + [ PackageLoader ( \"debug_toolbar\" , \"templates\" )] self . JINJA_ENV . loader = ChoiceLoader ( loaders ) self . JINJA_ENV . trim_blocks = True self . JINJA_ENV . lstrip_blocks = True for extension in self . JINJA_EXTENSIONS : self . JINJA_ENV . add_extension ( extension ) @root_validator ( pre = True ) def ci ( cls , values : t . Dict [ str , t . Any ]) -> t . Dict [ str , t . Any ]: return { k . upper (): v for k , v in values . items ()} ALLOWED_IPS : t . Optional [ t . Sequence [ IPvAnyAddress ]] = Field ( None , description = \"If it's set, the Debug Toolbar is shown only if your IP address is listed.\" ) class-attribute API_URL : str = Field ( '/_debug_toolbar' , description = 'URL prefix to use for toolbar endpoints.' ) class-attribute DEFAULT_PANELS : t . List [ str ] = Field ([ 'debug_toolbar.panels.versions.VersionsPanel' , 'debug_toolbar.panels.timer.TimerPanel' , 'debug_toolbar.panels.settings.SettingsPanel' , 'debug_toolbar.panels.request.RequestPanel' , 'debug_toolbar.panels.headers.HeadersPanel' , 'debug_toolbar.panels.pydantic.PydanticPanel' , 'debug_toolbar.panels.routes.RoutesPanel' , 'debug_toolbar.panels.logging.LoggingPanel' , 'debug_toolbar.panels.profiling.ProfilingPanel' , 'debug_toolbar.panels.redirects.RedirectsPanel' ], description = 'Specifies the full Python path to each panel that you want included in the toolbar.' ) class-attribute DISABLE_PANELS : t . Sequence [ str ] = Field ([ 'debug_toolbar.panels.redirects.RedirectsPanel' ], description = 'A list of the full Python paths to each panel that you want disabled (but still displayed) by default.' ) class-attribute INSERT_BEFORE : str = Field ( '</body>' , description = 'The toolbar searches for this string in the HTML and inserts itself just before.' ) class-attribute JINJA_ENV : Environment = Field ( Environment (), description = 'The Jinja environment instance used to render the toolbar.' ) class-attribute JINJA_EXTENSIONS : t . Sequence [ t . Union [ str , t . Type [ Extension ]]] = Field ([], description = 'Load the extensions from the list and bind them to the Jinja environment.' ) class-attribute JINJA_LOADERS : t . List [ BaseLoader ] = Field ([], description = 'Jinja `BaseLoader` subclasses used to load templates from the file system or other locations.' ) class-attribute LOGGING_COLORS : t . Dict [ str , Color ] = Field ({ 'CRITICAL' : Color ( 'rgba(255, 0, 0, .4)' ), 'ERROR' : Color ( 'rgba(255, 0, 0, .2)' ), 'WARNING' : Color ( 'rgba(255, 165, 0, .2)' ), 'INFO' : Color ( 'rgba(135, 206, 235, .2)' ), 'DEBUG' : Color ( 'rgba(128, 128, 128, .2)' )}, description = 'Color palette used to apply colors based on the log level.' ) class-attribute PANELS : t . List [ str ] = Field ([], description = 'A list of the full Python paths to each panel that you want to append to `DEFAULT_PANELS`.' ) class-attribute PROFILER_OPTIONS : t . Dict [ str , t . Any ] = Field ({ 'interval' : 0.0001 }, description = 'A list of arguments can be supplied to the Profiler.' ) class-attribute RESULTS_CACHE_SIZE : int = Field ( 25 , description = 'The toolbar keeps up to this many results in memory.' ) class-attribute ROOT_TAG_EXTRA_ATTRS : str = Field ( '' , description = 'This setting is injected in the root template div in order to avoid conflicts with client-side frameworks' ) class-attribute SETTINGS : t . Sequence [ BaseSettings ] = Field ([], description = \"pydantic's `BaseSettings` instances to be displayed on the `SettingsPanel`.\" ) class-attribute SHOW_COLLAPSE : bool = Field ( False , description = 'If changed to `True`, the toolbar will be collapsed by default.' ) class-attribute SHOW_TOOLBAR_CALLBACK : str = Field ( 'debug_toolbar.middleware.show_toolbar' , description = 'This is the dotted path to a function used for determining whether the toolbar should show or not.' ) class-attribute SQL_WARNING_THRESHOLD : int = Field ( 500 , description = 'The SQL panel highlights queries that took more that this amount of time, in milliseconds, to execute.' ) class-attribute STATIC_URL : str = Field ( f ' { API_URL . default } /static' , description = 'URL to use when referring to toolbar static files.' ) class-attribute","title":"Settings"},{"location":"settings/#debug_toolbar.settings.DebugToolbarSettings.ALLOWED_IPS","text":"","title":"ALLOWED_IPS"},{"location":"settings/#debug_toolbar.settings.DebugToolbarSettings.API_URL","text":"","title":"API_URL"},{"location":"settings/#debug_toolbar.settings.DebugToolbarSettings.DEFAULT_PANELS","text":"","title":"DEFAULT_PANELS"},{"location":"settings/#debug_toolbar.settings.DebugToolbarSettings.DISABLE_PANELS","text":"","title":"DISABLE_PANELS"},{"location":"settings/#debug_toolbar.settings.DebugToolbarSettings.INSERT_BEFORE","text":"","title":"INSERT_BEFORE"},{"location":"settings/#debug_toolbar.settings.DebugToolbarSettings.JINJA_ENV","text":"","title":"JINJA_ENV"},{"location":"settings/#debug_toolbar.settings.DebugToolbarSettings.JINJA_EXTENSIONS","text":"","title":"JINJA_EXTENSIONS"},{"location":"settings/#debug_toolbar.settings.DebugToolbarSettings.JINJA_LOADERS","text":"","title":"JINJA_LOADERS"},{"location":"settings/#debug_toolbar.settings.DebugToolbarSettings.LOGGING_COLORS","text":"","title":"LOGGING_COLORS"},{"location":"settings/#debug_toolbar.settings.DebugToolbarSettings.PANELS","text":"","title":"PANELS"},{"location":"settings/#debug_toolbar.settings.DebugToolbarSettings.PROFILER_OPTIONS","text":"","title":"PROFILER_OPTIONS"},{"location":"settings/#debug_toolbar.settings.DebugToolbarSettings.RESULTS_CACHE_SIZE","text":"","title":"RESULTS_CACHE_SIZE"},{"location":"settings/#debug_toolbar.settings.DebugToolbarSettings.ROOT_TAG_EXTRA_ATTRS","text":"","title":"ROOT_TAG_EXTRA_ATTRS"},{"location":"settings/#debug_toolbar.settings.DebugToolbarSettings.SETTINGS","text":"","title":"SETTINGS"},{"location":"settings/#debug_toolbar.settings.DebugToolbarSettings.SHOW_COLLAPSE","text":"","title":"SHOW_COLLAPSE"},{"location":"settings/#debug_toolbar.settings.DebugToolbarSettings.SHOW_TOOLBAR_CALLBACK","text":"","title":"SHOW_TOOLBAR_CALLBACK"},{"location":"settings/#debug_toolbar.settings.DebugToolbarSettings.SQL_WARNING_THRESHOLD","text":"","title":"SQL_WARNING_THRESHOLD"},{"location":"settings/#debug_toolbar.settings.DebugToolbarSettings.STATIC_URL","text":"","title":"STATIC_URL"},{"location":"panels/default/","text":"Here's a list of default panels available: Versions Timer Settings Add your pydantic's BaseSettings classes to this panel: from debug_toolbar.middleware import DebugToolbarMiddleware from fastapi import FastAPI from pydantic import BaseSettings , SecretStr class APISettings ( BaseSettings ): SECRET_KEY : SecretStr app = FastAPI ( debug = True ) app . add_middleware ( DebugToolbarMiddleware , settings = [ APISettings ()]) Request Headers Pydantic Routes Logging Profiling Profiling reports provided by Pyinstrument , you can configure the profiler parameters by adding profiler_options settings: from debug_toolbar.middleware import DebugToolbarMiddleware from fastapi import FastAPI app = FastAPI ( debug = True ) app . add_middleware ( DebugToolbarMiddleware , profiler_options = { 'interval' : .0002 })","title":"Default panels"},{"location":"panels/default/#versions","text":"","title":"Versions"},{"location":"panels/default/#timer","text":"","title":"Timer"},{"location":"panels/default/#settings","text":"Add your pydantic's BaseSettings classes to this panel: from debug_toolbar.middleware import DebugToolbarMiddleware from fastapi import FastAPI from pydantic import BaseSettings , SecretStr class APISettings ( BaseSettings ): SECRET_KEY : SecretStr app = FastAPI ( debug = True ) app . add_middleware ( DebugToolbarMiddleware , settings = [ APISettings ()])","title":"Settings"},{"location":"panels/default/#request","text":"","title":"Request"},{"location":"panels/default/#headers","text":"","title":"Headers"},{"location":"panels/default/#pydantic","text":"","title":"Pydantic"},{"location":"panels/default/#routes","text":"","title":"Routes"},{"location":"panels/default/#logging","text":"","title":"Logging"},{"location":"panels/default/#profiling","text":"Profiling reports provided by Pyinstrument , you can configure the profiler parameters by adding profiler_options settings: from debug_toolbar.middleware import DebugToolbarMiddleware from fastapi import FastAPI app = FastAPI ( debug = True ) app . add_middleware ( DebugToolbarMiddleware , profiler_options = { 'interval' : .0002 })","title":"Profiling"},{"location":"panels/dev/","text":"First steps Before writing your own panel you need to provide a Jinja loader instance used to load your templates from the file system or other locations. from debug_toolbar.middleware import DebugToolbarMiddleware from fastapi import FastAPI from fastapi.templating import Jinja2Templates app = FastAPI ( debug = True ) templates = Jinja2Templates ( directory = \"templates\" ) app . add_middleware ( DebugToolbarMiddleware , panels = [ \"panels.ExamplePanel\" ], jinja_loaders = [ templates . env . loader ], ) Create a panel Subclass Panel and override generate_stats() method to implement a custom panel on your panels.py . This method should return a dict with the panel stats. from debug_toolbar.panels import Panel class ExamplePanel ( Panel ): title = \"Example Panel\" template = \"example.html\" async def process_request ( self , request ): response = await super () . process_request ( request ) return response async def generate_stats ( self , request , response ): return { \"example\" : \"value\" } Tip The process_request() method is optional and particularly useful for adding behavior that occurs before the request is processed. Please see the Panel class reference for further details. Writing the template Create a template at templates/example.html to display your panel stats: < span > {{ example }} </ span >","title":"Development"},{"location":"panels/dev/#first-steps","text":"Before writing your own panel you need to provide a Jinja loader instance used to load your templates from the file system or other locations. from debug_toolbar.middleware import DebugToolbarMiddleware from fastapi import FastAPI from fastapi.templating import Jinja2Templates app = FastAPI ( debug = True ) templates = Jinja2Templates ( directory = \"templates\" ) app . add_middleware ( DebugToolbarMiddleware , panels = [ \"panels.ExamplePanel\" ], jinja_loaders = [ templates . env . loader ], )","title":"First steps"},{"location":"panels/dev/#create-a-panel","text":"Subclass Panel and override generate_stats() method to implement a custom panel on your panels.py . This method should return a dict with the panel stats. from debug_toolbar.panels import Panel class ExamplePanel ( Panel ): title = \"Example Panel\" template = \"example.html\" async def process_request ( self , request ): response = await super () . process_request ( request ) return response async def generate_stats ( self , request , response ): return { \"example\" : \"value\" } Tip The process_request() method is optional and particularly useful for adding behavior that occurs before the request is processed. Please see the Panel class reference for further details.","title":"Create a panel"},{"location":"panels/dev/#writing-the-template","text":"Create a template at templates/example.html to display your panel stats: < span > {{ example }} </ span >","title":"Writing the template"},{"location":"panels/panel/","text":"Source code in debug_toolbar/panels/__init__.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 class Panel : has_content : bool = True def __init__ ( self , toolbar : \"DebugToolbar\" , call_next : RequestResponseEndpoint , ) -> None : self . toolbar = toolbar self . call_next = call_next @property def panel_id ( self ) -> str : return self . __class__ . __name__ @property def enabled ( self ) -> bool : disabled_panels = self . toolbar . settings . DISABLE_PANELS panel_path = get_name_from_obj ( self ) disable_panel = ( panel_path in disabled_panels or panel_path . replace ( \".panel.\" , \".\" ) in disabled_panels ) if disable_panel : default = \"off\" else : default = \"on\" return self . toolbar . request . cookies . get ( f \"dt { self . panel_id } \" , default ) == \"on\" @property def nav_title ( self ) -> str : return self . title @property def nav_subtitle ( self ) -> str : return \"\" @property def title ( self ) -> str : raise NotImplementedError @property def template ( self ) -> str : raise NotImplementedError @property def content ( self ) -> str : if self . has_content : return self . render ( ** self . get_stats ()) return \"\" def render ( self , ** context : t . Any ) -> str : return self . toolbar . render ( self . template , ** context ) def url_for ( self , name : str , ** path_params : t . Any ) -> str : return self . toolbar . request . url_for ( name , ** path_params ) @property def scripts ( self ) -> t . List [ str ]: return [] async def process_request ( self , request : Request ) -> Response : return await self . call_next ( request ) async def generate_stats ( self , request : Request , response : Response ) -> Stats : return {} def get_stats ( self ) -> Stats : return self . toolbar . stats . get ( self . panel_id , {}) async def record_stats ( self , request : Request , response : Response ) -> None : stats = await self . generate_stats ( request , response ) if stats is not None : self . toolbar . stats . setdefault ( self . panel_id , {}) . update ( stats ) async def generate_server_timing ( self , request : Request , response : Response , ) -> ServerTiming : return [] def get_server_timing_stats ( self ) -> ServerTiming : return self . toolbar . server_timing_stats . get ( self . panel_id , []) async def record_server_timing ( self , request : Request , response : Response ) -> None : stats = await self . generate_server_timing ( request , response ) if stats is not None : st_stats = self . toolbar . server_timing_stats . setdefault ( self . panel_id , []) st_stats += list ( stats ) call_next = call_next instance-attribute content : str property enabled : bool property has_content : bool = True class-attribute nav_subtitle : str property nav_title : str property panel_id : str property scripts : t . List [ str ] property template : str property title : str property toolbar = toolbar instance-attribute __init__ ( toolbar , call_next ) Source code in debug_toolbar/panels/__init__.py 16 17 18 19 20 21 22 def __init__ ( self , toolbar : \"DebugToolbar\" , call_next : RequestResponseEndpoint , ) -> None : self . toolbar = toolbar self . call_next = call_next generate_server_timing ( request , response ) async Source code in debug_toolbar/panels/__init__.py 91 92 93 94 95 96 async def generate_server_timing ( self , request : Request , response : Response , ) -> ServerTiming : return [] generate_stats ( request , response ) async Source code in debug_toolbar/panels/__init__.py 79 80 async def generate_stats ( self , request : Request , response : Response ) -> Stats : return {} get_server_timing_stats () Source code in debug_toolbar/panels/__init__.py 98 99 def get_server_timing_stats ( self ) -> ServerTiming : return self . toolbar . server_timing_stats . get ( self . panel_id , []) get_stats () Source code in debug_toolbar/panels/__init__.py 82 83 def get_stats ( self ) -> Stats : return self . toolbar . stats . get ( self . panel_id , {}) process_request ( request ) async Source code in debug_toolbar/panels/__init__.py 76 77 async def process_request ( self , request : Request ) -> Response : return await self . call_next ( request ) record_server_timing ( request , response ) async Source code in debug_toolbar/panels/__init__.py 101 102 103 104 105 106 async def record_server_timing ( self , request : Request , response : Response ) -> None : stats = await self . generate_server_timing ( request , response ) if stats is not None : st_stats = self . toolbar . server_timing_stats . setdefault ( self . panel_id , []) st_stats += list ( stats ) record_stats ( request , response ) async Source code in debug_toolbar/panels/__init__.py 85 86 87 88 89 async def record_stats ( self , request : Request , response : Response ) -> None : stats = await self . generate_stats ( request , response ) if stats is not None : self . toolbar . stats . setdefault ( self . panel_id , {}) . update ( stats ) render ( ** context ) Source code in debug_toolbar/panels/__init__.py 66 67 def render ( self , ** context : t . Any ) -> str : return self . toolbar . render ( self . template , ** context ) url_for ( name , ** path_params ) Source code in debug_toolbar/panels/__init__.py 69 70 def url_for ( self , name : str , ** path_params : t . Any ) -> str : return self . toolbar . request . url_for ( name , ** path_params )","title":"Panel"},{"location":"panels/panel/#debug_toolbar.panels.Panel.call_next","text":"","title":"call_next"},{"location":"panels/panel/#debug_toolbar.panels.Panel.content","text":"","title":"content"},{"location":"panels/panel/#debug_toolbar.panels.Panel.enabled","text":"","title":"enabled"},{"location":"panels/panel/#debug_toolbar.panels.Panel.has_content","text":"","title":"has_content"},{"location":"panels/panel/#debug_toolbar.panels.Panel.nav_subtitle","text":"","title":"nav_subtitle"},{"location":"panels/panel/#debug_toolbar.panels.Panel.nav_title","text":"","title":"nav_title"},{"location":"panels/panel/#debug_toolbar.panels.Panel.panel_id","text":"","title":"panel_id"},{"location":"panels/panel/#debug_toolbar.panels.Panel.scripts","text":"","title":"scripts"},{"location":"panels/panel/#debug_toolbar.panels.Panel.template","text":"","title":"template"},{"location":"panels/panel/#debug_toolbar.panels.Panel.title","text":"","title":"title"},{"location":"panels/panel/#debug_toolbar.panels.Panel.toolbar","text":"","title":"toolbar"},{"location":"panels/panel/#debug_toolbar.panels.Panel.__init__","text":"Source code in debug_toolbar/panels/__init__.py 16 17 18 19 20 21 22 def __init__ ( self , toolbar : \"DebugToolbar\" , call_next : RequestResponseEndpoint , ) -> None : self . toolbar = toolbar self . call_next = call_next","title":"__init__()"},{"location":"panels/panel/#debug_toolbar.panels.Panel.generate_server_timing","text":"Source code in debug_toolbar/panels/__init__.py 91 92 93 94 95 96 async def generate_server_timing ( self , request : Request , response : Response , ) -> ServerTiming : return []","title":"generate_server_timing()"},{"location":"panels/panel/#debug_toolbar.panels.Panel.generate_stats","text":"Source code in debug_toolbar/panels/__init__.py 79 80 async def generate_stats ( self , request : Request , response : Response ) -> Stats : return {}","title":"generate_stats()"},{"location":"panels/panel/#debug_toolbar.panels.Panel.get_server_timing_stats","text":"Source code in debug_toolbar/panels/__init__.py 98 99 def get_server_timing_stats ( self ) -> ServerTiming : return self . toolbar . server_timing_stats . get ( self . panel_id , [])","title":"get_server_timing_stats()"},{"location":"panels/panel/#debug_toolbar.panels.Panel.get_stats","text":"Source code in debug_toolbar/panels/__init__.py 82 83 def get_stats ( self ) -> Stats : return self . toolbar . stats . get ( self . panel_id , {})","title":"get_stats()"},{"location":"panels/panel/#debug_toolbar.panels.Panel.process_request","text":"Source code in debug_toolbar/panels/__init__.py 76 77 async def process_request ( self , request : Request ) -> Response : return await self . call_next ( request )","title":"process_request()"},{"location":"panels/panel/#debug_toolbar.panels.Panel.record_server_timing","text":"Source code in debug_toolbar/panels/__init__.py 101 102 103 104 105 106 async def record_server_timing ( self , request : Request , response : Response ) -> None : stats = await self . generate_server_timing ( request , response ) if stats is not None : st_stats = self . toolbar . server_timing_stats . setdefault ( self . panel_id , []) st_stats += list ( stats )","title":"record_server_timing()"},{"location":"panels/panel/#debug_toolbar.panels.Panel.record_stats","text":"Source code in debug_toolbar/panels/__init__.py 85 86 87 88 89 async def record_stats ( self , request : Request , response : Response ) -> None : stats = await self . generate_stats ( request , response ) if stats is not None : self . toolbar . stats . setdefault ( self . panel_id , {}) . update ( stats )","title":"record_stats()"},{"location":"panels/panel/#debug_toolbar.panels.Panel.render","text":"Source code in debug_toolbar/panels/__init__.py 66 67 def render ( self , ** context : t . Any ) -> str : return self . toolbar . render ( self . template , ** context )","title":"render()"},{"location":"panels/panel/#debug_toolbar.panels.Panel.url_for","text":"Source code in debug_toolbar/panels/__init__.py 69 70 def url_for ( self , name : str , ** path_params : t . Any ) -> str : return self . toolbar . request . url_for ( name , ** path_params )","title":"url_for()"},{"location":"panels/sql/","text":"SQLAlchemy Add the SQLAlchemyPanel to your panel list: from debug_toolbar.middleware import DebugToolbarMiddleware from fastapi import FastAPI app = FastAPI ( debug = True ) app . add_middleware ( DebugToolbarMiddleware , panels = [ \"debug_toolbar.panels.sqlalchemy.SQLAlchemyPanel\" ], ) This panel records all queries using the \"Dependency Injection\" system as described in the FastAPI docs . If you don't use dependencies then create a new class that inherits from SQLAlchemyPanel , override the add_engines method and add the class path to your panel list: from debug_toolbar.panels.sqlalchemy import SQLAlchemyPanel as BasePanel from sqlalchemy import create_engine engine = create_engine ( \"sqlite://\" , connect_args = { \"check_same_thread\" : False }) class SQLAlchemyPanel ( BasePanel ): async def add_engines ( self , request : Request ): self . engines . add ( engine ) debug_toolbar.panels.sqlalchemy.SQLAlchemyPanel Source code in debug_toolbar/panels/sqlalchemy.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 class SQLAlchemyPanel ( SQLPanel ): title = \"SQLAlchemy\" def __init__ ( self , * args : t . Any , ** kwargs : t . Any ) -> None : super () . __init__ ( * args , ** kwargs ) self . engines : t . Set [ Engine ] = set () def register ( self , engine : Engine ) -> None : event . listen ( engine , \"before_cursor_execute\" , self . before_execute ) event . listen ( engine , \"after_cursor_execute\" , self . after_execute ) def unregister ( self , engine : Engine ) -> None : event . remove ( engine , \"before_cursor_execute\" , self . before_execute ) event . remove ( engine , \"after_cursor_execute\" , self . after_execute ) def before_execute ( self , conn : Connection , cursor : t . Any , statement : str , parameters : t . Union [ t . Sequence , t . Dict ], context : DefaultExecutionContext , executemany : bool , ) -> None : conn . info . setdefault ( \"start_time\" , []) . append ( perf_counter ()) def after_execute ( self , conn : Connection , cursor : t . Any , statement : str , parameters : t . Union [ t . Sequence , t . Dict ], context : DefaultExecutionContext , executemany : bool , ) -> None : query = { \"duration\" : ( perf_counter () - conn . info [ \"start_time\" ] . pop ( - 1 )) * 1000 , \"sql\" : statement , \"params\" : parameters , \"is_select\" : context . invoked_statement . is_select , } self . add_query ( str ( conn . engine . url ), query ) async def add_engines ( self , request : Request ): route = request [ \"route\" ] if hasattr ( route , \"dependant\" ): if \"fastapi_astack\" not in request : async with AsyncExitStack () as stack : request . scope [ \"fastapi_astack\" ] = stack solved_result = await solve_dependencies ( request = request , dependant = route . dependant , dependency_overrides_provider = route . dependency_overrides_provider , ) for value in solved_result [ 0 ] . values (): if isinstance ( value , Session ): self . engines . add ( value . get_bind ()) async def process_request ( self , request : Request ) -> Response : await self . add_engines ( request ) for engine in self . engines : self . register ( engine ) try : response = await super () . process_request ( request ) finally : for engine in self . engines : self . unregister ( engine ) return response add_engines ( request ) async Source code in debug_toolbar/panels/sqlalchemy.py 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 async def add_engines ( self , request : Request ): route = request [ \"route\" ] if hasattr ( route , \"dependant\" ): if \"fastapi_astack\" not in request : async with AsyncExitStack () as stack : request . scope [ \"fastapi_astack\" ] = stack solved_result = await solve_dependencies ( request = request , dependant = route . dependant , dependency_overrides_provider = route . dependency_overrides_provider , ) for value in solved_result [ 0 ] . values (): if isinstance ( value , Session ): self . engines . add ( value . get_bind ()) Tortoise ORM Add the TortoisePanel to your panel list: from debug_toolbar.middleware import DebugToolbarMiddleware from fastapi import FastAPI app = FastAPI ( debug = True ) app . add_middleware ( DebugToolbarMiddleware , panels = [ \"debug_toolbar.panels.tortoise.TortoisePanel\" ], )","title":"SQL panels"},{"location":"panels/sql/#sqlalchemy","text":"Add the SQLAlchemyPanel to your panel list: from debug_toolbar.middleware import DebugToolbarMiddleware from fastapi import FastAPI app = FastAPI ( debug = True ) app . add_middleware ( DebugToolbarMiddleware , panels = [ \"debug_toolbar.panels.sqlalchemy.SQLAlchemyPanel\" ], ) This panel records all queries using the \"Dependency Injection\" system as described in the FastAPI docs . If you don't use dependencies then create a new class that inherits from SQLAlchemyPanel , override the add_engines method and add the class path to your panel list: from debug_toolbar.panels.sqlalchemy import SQLAlchemyPanel as BasePanel from sqlalchemy import create_engine engine = create_engine ( \"sqlite://\" , connect_args = { \"check_same_thread\" : False }) class SQLAlchemyPanel ( BasePanel ): async def add_engines ( self , request : Request ): self . engines . add ( engine )","title":"SQLAlchemy"},{"location":"panels/sql/#debug_toolbar.panels.sqlalchemy.SQLAlchemyPanel","text":"Source code in debug_toolbar/panels/sqlalchemy.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 class SQLAlchemyPanel ( SQLPanel ): title = \"SQLAlchemy\" def __init__ ( self , * args : t . Any , ** kwargs : t . Any ) -> None : super () . __init__ ( * args , ** kwargs ) self . engines : t . Set [ Engine ] = set () def register ( self , engine : Engine ) -> None : event . listen ( engine , \"before_cursor_execute\" , self . before_execute ) event . listen ( engine , \"after_cursor_execute\" , self . after_execute ) def unregister ( self , engine : Engine ) -> None : event . remove ( engine , \"before_cursor_execute\" , self . before_execute ) event . remove ( engine , \"after_cursor_execute\" , self . after_execute ) def before_execute ( self , conn : Connection , cursor : t . Any , statement : str , parameters : t . Union [ t . Sequence , t . Dict ], context : DefaultExecutionContext , executemany : bool , ) -> None : conn . info . setdefault ( \"start_time\" , []) . append ( perf_counter ()) def after_execute ( self , conn : Connection , cursor : t . Any , statement : str , parameters : t . Union [ t . Sequence , t . Dict ], context : DefaultExecutionContext , executemany : bool , ) -> None : query = { \"duration\" : ( perf_counter () - conn . info [ \"start_time\" ] . pop ( - 1 )) * 1000 , \"sql\" : statement , \"params\" : parameters , \"is_select\" : context . invoked_statement . is_select , } self . add_query ( str ( conn . engine . url ), query ) async def add_engines ( self , request : Request ): route = request [ \"route\" ] if hasattr ( route , \"dependant\" ): if \"fastapi_astack\" not in request : async with AsyncExitStack () as stack : request . scope [ \"fastapi_astack\" ] = stack solved_result = await solve_dependencies ( request = request , dependant = route . dependant , dependency_overrides_provider = route . dependency_overrides_provider , ) for value in solved_result [ 0 ] . values (): if isinstance ( value , Session ): self . engines . add ( value . get_bind ()) async def process_request ( self , request : Request ) -> Response : await self . add_engines ( request ) for engine in self . engines : self . register ( engine ) try : response = await super () . process_request ( request ) finally : for engine in self . engines : self . unregister ( engine ) return response","title":"SQLAlchemyPanel"},{"location":"panels/sql/#debug_toolbar.panels.sqlalchemy.SQLAlchemyPanel.add_engines","text":"Source code in debug_toolbar/panels/sqlalchemy.py 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 async def add_engines ( self , request : Request ): route = request [ \"route\" ] if hasattr ( route , \"dependant\" ): if \"fastapi_astack\" not in request : async with AsyncExitStack () as stack : request . scope [ \"fastapi_astack\" ] = stack solved_result = await solve_dependencies ( request = request , dependant = route . dependant , dependency_overrides_provider = route . dependency_overrides_provider , ) for value in solved_result [ 0 ] . values (): if isinstance ( value , Session ): self . engines . add ( value . get_bind ())","title":"add_engines()"},{"location":"panels/sql/#tortoise-orm","text":"Add the TortoisePanel to your panel list: from debug_toolbar.middleware import DebugToolbarMiddleware from fastapi import FastAPI app = FastAPI ( debug = True ) app . add_middleware ( DebugToolbarMiddleware , panels = [ \"debug_toolbar.panels.tortoise.TortoisePanel\" ], )","title":"Tortoise ORM"}]}